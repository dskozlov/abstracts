# Git


# SHA == commit_id (например, b4b3fb6d0593d425b836cfa044b1b20721a45fcb)

# Команды
## Документация по командам
git help
  <command_name>  # описание конкретной команды

# Задать конфигурацию Git
git config
  --list          # перечень параметров
  --local         # для текущего репозитория (.git/config)
  --system        # для всех проектов на компьютере (/etc/gitconfig)
  --global        # для всех проектов пользователя (~/.gitconfig)
    user.name "Igor Polyakov"
    user.email igor_polyakov@phystech.edu
    color.ui true # раскрасить сообщения Git в терминале

    # Продвинутые настройки
    core.autocrlf input # переносы строки для пользователей UNIX
    core.autocrlf true  # переносы строки для пользователей Windows
    push.default simple # заливает на сервер текущую ветку без вопросов
    pull.rebase true    # команда pull по умолчанию выполняется с опцией --rebase
    rerere.enabled true # записывает способ разрешения конфликта и разрешает его автоматически в подобной ситуации (используется при cherry picking нескольких веток или постоянном ребейсе)

    # Собственные команды
    alias.<cmd_name> "git_cmd"  # см. др. примеры в конце файла
    ## Пример:
    alias.s status  # аббревиатура для команды

## Создать контроль версий (создать хранилище ./.git/ в выбранной папке)
git init

## Удалённые репозитории
git remote
  add <name> <address> # создать удалённый репозиторий
  add origin https://github.com/noggatur/new_repo.git # на GitHub
  -v                   # показать удалённый репозиторий
  rm <name>            # удалить удалённый репозиторий
  show origin          # показать текущее состояние веток
  prune origin         # убрать ветки удалённые с сервера

# Копирование репозитория
git clone
  <address> # копирует удалённый репозиторий в текущий каталог
  <path/to/proj_1> <path/to/proj_2> # копия репозитория

## Посмотреть изменения в системе
git status

## Посмотреть историю коммитов
git log
  -n <num>           # num коммитов
  -<num>             # num коммитов
  --since=2016-09-23 # все коммиты, начиная с указанной даты
  --until=2016-09-23 # все коммиты, до указанной даты
    1.day.ago        # minute, hour, month, week
  --author="Igor"    # все коммиты указанного автора
  --grep="smth"      # поиск по коммитам через регулярное выражение
  HEAD               # последний коммит
  -p                 # добавляет данные из diff
  --stat             # добавляется информация о количестве изменений в коммите
  --summary          # статистика изменений
  --graph            # графическое представление коммитов
  --walk-reflogs     # для отслеживания перемещения указателя HEAD
  <SHA>.. <file>     # первый коммит, в котором появляется файл <file>, начиная с коммита <SHA>
  --pretty=oneline   # хэш и сообщение
  --pretty=format:"%h %ad- %s [%an]" # произвольный формат коммитов
    %ad # имя автора
    %an # дата (автора)
    %h  # хэш
    %s  # сообщение
    %d  # ссылки

## Посмотреть изменения
git diff  # все
  <file || branch>          # в конкретном файле
  $1 $2 --stat -- . | wc -l # количество изменений
  --staged                  # изменения в добавленных (перед коммитом) файлах
  --color-words             # показывает изменения прямо в строчке
  HEAD~5                    # по сравнению с 5м с конца коммитом
  HEAD^..HEAD               # сравнение последнего с предпоследним
  <SHA_1>..<SHA_2>          # сравнение одного с другим

# Посмотреть, кто написал каждую строку в файле
git blame <file>
  --date short # короткая запись даты

## Принять изменения (отслеживать изменения в файлах)
git add
  <file>  # в файле
  .       # в текущей папке
  --all   # все файлы
  "*.txt" # во всех файлах проекта с расширением txt
  *.txt   # во всех файлах текущей папки с расширением txt

## Удалить файл и принять это изменение
git rm <file>     # работают те же обозначения, что и для add
  --cached <file> # удалить только из отслеживания изменений

## Переместить файл и принять это изменение
git mv <путь_1/к/файлу> <путь_2/к/файлу>

## Закоммитить изменения (сохранить версию) и описать их
git commit -m "Commit message"
  --amend -m "Amended commit message" # изменить последний коммит, добавив в него новую информацию, и его сообщение (не прокатит, если изменения уже залиты в удалённый репозиторий)
  -a                                  # добавить изменения в отслеживаемых файлах
### Коммиты желательно писать в настоящем времени
### Придерживаться одних и тех же тегов (кодированию изменений)
### Изменения следует описывать максимально конкретно
### Коммиты могут содержать довольно большое описание. В этом случае важно написать краткое пояснение, а затем более развёрнутое через 1 строчку

# Маркировка (для обозначения ключевых версий проекта)
git tag # список маркеров
  -a <tag_name> -m "Tag message." # добавить маркер
git push --tags # залить теги на сервер
## Маркировка обычно делается каждый раз при заливке кода в продакшн
## Примеры маркировок
### v1.0
### v2.3.4
### v0.2-alpha
### v5.9-beta.3

## HEAD — указатель на текущий коммит текущей ветки

## Передвинуть указатель назад
git reset
  <file>                 # выкинуть файл из истории
  HEAD <file>            # отменить принятое изменение
  --soft <SHA || HEAD^>  # не меняет ни изменения, ни рабочую папку
  --mixed <SHA || HEAD^> # меняет только изменения, но не рабочую папку
  --hard <SHA || HEAD^>  # меняет всё
## перед использованием этой команды правильно будет скопировать данные о последних 3х коммитах

# Также можно посмотреть историю перемещения указателя HEAD
git reflog

## Удалить неотслеживаемые изменения
git clean
  -n  # проверить, что будет удаляться
  -f  # удалить

# Ветки
git branch            # посмотреть имеющиеся ветки
  <branch_name>       # создать ветку
  -d <branch_name>    # удалить ветку
  -D <branch_name>    # удалить ветку в локальном репозитории
  <branch_name> <SHA> # создать ветку c версией указанного коммита (можно ссылаться и на коммиты удалённых веток)
  -a                  # список всех веток
  -r                  # список удалённых веток
  --merged            # показывает соединённые ветки
  -m <branch_name_old> <branch_name_new> # переименовать ветку

## Перейти к определённой версии
git checkout
  <file || SHA || branch || tag> # перейти к версию файла, коммита или ветки
  -- <file>                      # перейти к последней версии файла, оставаясь на той же ветке
  <SHA || part_of_the_commit_id> -- <file>  # вернуться к определённой версии файла. после этого необходимо сделать следующее:
    git reset HEAD <file>
    git checkout -- <file>
  -b <branch_name>               # создать и перейти в ветку

# Слить текущую ветку с другой веткой
git merge
  <branch_name>
  --no-ff <branch_name> # не fast-forward merge, а recursive merge (сохраняет все коммиты)
## Существует множество инструментов для слития веток
git mergetool
## Также для сокращения количества возможных конфликтов следует
### строчки кода писать короткими
### коммиты делать маленькими и сфокусированными
### избегать лишних пробелов, табов и окончания строк
### чаще мерджить
### периодически подхватывать изменения из мастера

## Вернуться к коммиту
git revert <SHA || part_of_the_commit_id>

## Запилить последнюю версию проекта на GitHub
git push
  <name> <branch>
  <name> <local_branch>:<remote_branch>
  -u origin master # после этого можно просто git push
  origin :<branch> # удалить ветку в удалённом репозитории
  --tags           # залить теги на сервер
### GitHub не заботится о контроле доступа к репозиторию.
### Есть альтернативные варианты репозиториев: BitBicket, Gitosis, Gitorious.
### В последних 2 реализован контроль доступа.

# Загрузить последние изменения с сервера, но не сливать с веткой
git fetch # для всех веток
  <name> <branch> # для ветки <branch>

# Загрузить последние изменения с сервера и слить с текущей веткой
git pull          # fetch + merge
  --rebase        # fetch + rebase
  <name> <branch> # из ветки <branch>


# Добавить в текущую ветку изменения коммита (из другой ветки, разумеется)
git cherry-pick
  <SHA>
  --edit <SHA>                # изменить сообщение коммита
  --no-commit <SHA_1> <SHA_2> # взять изменения обоих коммитов, но не коммитить
  -x <SHA>                    # добавляет в сообщение (cherry-picked from commit ...)
  --signoff <SHA>             # автор этого черрипикинга

# Вставить изменения перед текущими изменениями
git rebase   # выполняется после git fetch
  <branch>   # из ветки <branch>
  --continue # продолжить после разрешения конфликта
  -i HEAD~3  # интерактивный процесс при котором коммиты можно
    # Эти команды появляются в файле, который предлагается изменить
    pick   # менять местами (далее это слово можно заменять)
    reword # переименовывать
    edit   # изменять (в том числе и делить на несколько коммитов)
    squash # соединить с предыдущим


## Скрыть изменения с последнего коммита
git stash
  save                      # сохранить изменённые файлы (можно не писать)
  save "Stash message."     # Описание изменений
  save --keep-index         # спрятать только незастейдженные изменения
  save --include-untracked  # спрятать в том числе и новые (неотслеживаемые) файлы
  list                      # список (стэк) спрятанных состояний
    --stat # со статистикой
  show stash@{2}            # показать указанный стэш; по умолчанию — 0 элемент
    --patch # аналог diff
  apply                     # вернуть изменения
  drop                      # удалить спрятанные изменения
  clear                     # очищает список с изменениями
  apply stash@{2}           # вернуть указанное изменение (из списка); по умолчанию — 0 элемент
  drop stash@{2}            # удалить спрятанные изменения (из списка); по умолчанию — 0 элемент
  pop                       # вернуть изменения и удалить их из списка (apply && drop)
  branch <branch> stash@{0} # поместить спрятанные изменения в новую ветку


# Редактирование истории
git filter-branch
  [-f] --tree-filter # ко всему дереву применяется команда Bash
    "rm -f passwords.txt"                 # удаление нежелательного файла
    "find . -name '*.mp4' -exec rm {} \;" # удаление нежелательных файлов
  --tree-filter "bash_command" -- --all # применение команды ко всем веткам и коммитам
  --tree-filter "bash_command" -- HEAD  # применение команды к текущей ветке
  [-f] --index-filter "git rm --cached --ignore-unmatch passwords.txt" # гораздо более быстрое выполнение команды для большого репозитория
  -f --prune-empty -- --all             # удалить все пустые коммиты


???????????????????

# Подмодули
git submodule
  add git@example.com:css.git
  init
  update  # чтобы скачать подмодуль из интернета

# Проверка, залиты ли прежде всего изменения модуля:
git push --recurse-submodules=check
# Заливаются все изменения с подмодулями так:
git push --recurse-submodules=on-demand

???????????????????



# Мои команды
## Быстрый доступ к состоянию реопзитория
git config --global alias.s "status -s"
## Отображение дерева коммитов в удобном виде
git config --global alias.lg "log --oneline --decorate --all --graph"
## Время создания коммита
git show -s --date=iso-strict-local --pretty=format:'%ad' <SHA>



# Игнорирование файлов
## Информация об игнорируемых файлах содержится в файле проекта .gitignore
## В нём перечисляются все файлы и папки
## Кроме того, можно задавать регулярные выражения с помощью символов
*, ?, [aeiou], [0-9]
## !этот_файл_не_игнорируется.html
## Строчные комментарии начинаются с символа #
## В проекте следует игнорировать
##   - скомпилированный код
##   - архивы
##   - логи и базы данных
##   - файлы, сгенерированные операционной системой
##   - файлы, загруженные пользователем
## Гобальное игнорирование:
git config --global core.excludesfile ~/.gitignore_global
### По умолчанию, Git игнорирует пустые папки (следит только за файлами). Если же нужно создать пустую папку, то в неё также нужно добавить файл .gitkeep
## Можно исключить файл также в файле ./.git/info/exclude
## Это исключение будет доступно только на одной машине, в отличие от информации в .gitignore


# Дополнительные фишки
## Настройка автозаполнения в Git
curl -OL http://github.com/git/git/raw/master/contrib/completion/git-completion.bash
mv ~/git-completion.bash ~/.git-completion.bash
### Прописать в .bash_profile
if [ -f ~/.git-completion.bash ]; then
  sourse ~/.git-completion.bash
fi

## Отображение ветки и рабочей папки в терминале (работает при наличии .git-completion)
export PS1='\W$(__git_ps1 "(%s)")> '

# С помощью GitHub API можно обращаться к возможностям сайта из терминала

# Клиенты git с графическим интерфейсом
# # Mac
# http://gitx.org
# http://mac.github.com
# http://sourcetreeapp.com
# http://git-tower.com
# http://gitboxapp.com
# # Windows
# http://code.google.com/p/tortoisegit
# http://code.google.com/p/gitextensions
# http://windows.github.com
# # Multiplatform
# syntevo.com/smartgit
# https://git.wiki.kernel.org/index.php/Gitweb


# Источники
# [x] https://try.github.io (введение в Git)
# [ ] https://www.codeschool.com/learn/git (практический курс)
# [ ] https://www.lynda.com/Git-tutorials/Git-Essential-Training/100222-2.html (теоретический курс)
# [ ] https://git-scm.com/book/en/v2 (лучшая книжка по Git)
# [ ] https://git-scm.com (графический интерфейс)
# [ ] https://desktop.github.com (полезное приложение)
# [ ] https://github.com/github/gitignore (про игнорирование файлов)
# [ ] https://help.github.com/articles/ignoring-files (про игнорирование файлов)
# [ ] https://help.github.com/articles/set-up-git (настроить Git так, чтобы не вводить пароль при обмене данными с сервером)
# [ ] http://gitimmersion.com
# [ ] http://gitready.com
# [ ] http://ndpsoftware.com/git-cheatsheet.html (шпаргалка)
# [ ] http://ftp.newartisans.com/pub/git.from.bottom.up.pdf
# [ ] https://github.com/pluralsight/git-internals-pdf
# [ ] Jon Loeliger — Version Control with Git
# Статьи
# [ ] http://nvie.com/posts/a-successful-git-branching-model/
# [ ] http://scottchacon.com/2011/08/31/github-flow.html
# [ ] http://semver.org (про версификацию)
# [ ] Чакон, Штрауб — Git для профессионального программиста
# [ ] Jon Loeliger — Version Control with Git