# Git


# SHA == commit_id (например, b4b3fb6d0593d425b836cfa044b1b20721a45fcb)

# Команды
## Документация по командам
git help
	<command_name>	# описание конкретной команды

# Задать конфигурацию Git
git config
	--list					# перечень параметров
	--local					# для текущего репозитория (.git/config)
	--system				# для всех проектов на компьютере (/etc/gitconfig)
	--global				# для всех проектов пользователя (~/.gitconfig)
		user.name "Igor Polyakov"
		user.email igor_polyakov@phystech.edu
		color.ui true	# раскрасить сообщения Git в терминале

		# Продвинутые настройки
		core.autocrlf input	# переносы строки для пользователей UNIX
		core.autocrlf true	# переносы строки для пользователей Windows
		push.default simple	# заливает на сервер текущую ветку без вопросов
		pull.rebase true	# команда pull по умолчанию выполняется с опцией --rebase
		rerere.enabled true	# записывает способ разрешения конфликта и разрешает его автоматически в подобной ситуации (используется при cherry picking нескольких веток или постоянном ребейсе)

		# Собственные команды
		alias.<cmd_name> "git_cmd"	# см. др. примеры в конце файла
		## Пример:
		alias.s status	# аббревиатура для команды

## Создать контроль версий (создать хранилище ./.git/ в выбранной папке)
git init

## Удалённые репозитории
git remote
	add <name> <address>								# создать удалённый репозиторий
	add origin https://github.com/noggatur/new_repo.git	# на GitHub
	-v													# показать удалённый репозиторий
	rm <name>											# удалить удалённый репозиторий
	show origin											# показать текущее состояние веток
	prune origin										# убрать ветки удалённые с сервера

# Копирование репозитория
git clone
	<address>	# копирует удалённый репозиторий в текущий каталог
	<path/to/proj_1> <path/to/proj_2>	# копия репозитория

## Посмотреть изменения в системе
git status

## Посмотреть историю коммитов
git log
	-n <num>			# num коммитов
	-<num>				# num коммитов
	--since=2016-09-23	# все коммиты, начиная с указанной даты
	--until=2016-09-23	# все коммиты, до указанной даты
		1.day.ago	# minute, hour, month, week
	--author="Igor"		# все коммиты указанного автора
	--grep="smth"		# поиск по коммитам через регулярное выражение
	HEAD				# последний коммит
	--pretty=oneline	# хэш и сообщение
	--pretty=format:"%h %ad- %s [%an]"	# произвольный формат коммитов
		%ad	# имя автора
		%an	# дата (автора)
		%h	# хэш
		%s	# сообщение
		%d	# ссылки
	-p		# добавляет данные из diff
	--stat	# добавляется информация о количестве изменений в коммите
	--summary	# статистика изменений
	--graph	# графическое представление коммитов
	--walk-reflogs	# для отслеживания перемещения указателя HEAD
	<SHA>.. <file>	# первый коммит, в котором появляется файл <file>, начиная с коммита <SHA>

## Посмотреть изменения
git diff	# все
	<file || branch>			# в конкретном файле
	$1 $2 --stat -- . | wc -l	# количество изменений
	--staged					# изменения в добавленных (перед коммитом) файлах
	--color-words				# показывает изменения прямо в строчке
	HEAD~5						# по сравнению с 5м с конца коммитом
	HEAD^..HEAD					# сравнение последнего с предпоследним
	<SHA_1>..<SHA_2>			# сравнение одного с другим

# Посмотреть, кто написал каждую строку в файле
git blame <file>
	--date short	# короткая запись даты

## Принять изменения (отслеживать изменения в файлах)
git add
	<file>	# в файле
	.		# в текущей папке
	--all	# все файлы
	"*.txt"	# во всех файлах проекта с расширением txt
	*.txt	# во всех файлах текущей папки с расширением txt

## Удалить файл и принять это изменение
git rm <file>	# работают те же обозначения, что и для add
	--cached <file>	# удалить только из отслеживания изменений

## Переместить файл и принять это изменение
git mv <путь_1/к/файлу> <путь_2/к/файлу>

## Закоммитить изменения (сохранить версию) и описать их
git commit -m "Commit message"
	--amend -m "Amended commit message"	# изменить последний коммит, добавив в него новую информацию, и его сообщение (не прокатит, если изменения уже залиты в удалённый репозиторий)
	-a									# добавить изменения в отслеживаемых файлах
### Коммиты желательно писать в настоящем времени
### Придерживаться одних и тех же тегов (кодированию изменений)
### Изменения следует описывать максимально конкретно
### Коммиты могут содержать довольно большое описание. В этом случае важно написать краткое пояснение, а затем более развёрнутое через 1 строчку

# Маркировка (для обозначения ключевых версий проекта)
git tag	# список маркеров
	-a <tag_name> -m "Tag message."	# добавить маркер
git push --tags	# залить теги на сервер
## Маркировка обычно делается каждый раз при заливке кода в продакшн
## Примеры маркировок
### v1.0
### v2.3.4
### v0.2-alpha
### v5.9-beta.3

## HEAD — указатель на текущий коммит текущей ветки

## Передвинуть указатель назад
git reset
	<file>				# выкинуть файл из истории
	HEAD <file>			# отменить принятое изменение
	--soft <SHA || HEAD^>	# не меняет ни изменения, ни рабочую папку
	--mixed <SHA || HEAD^>	# меняет только изменения, но не рабочую папку
	--hard <SHA || HEAD^>	# меняет всё
## перед использованием этой команды правильно будет скопировать данные о последних 3х коммитах

# Также можно посмотреть историю перемещения указателя HEAD
git reflog

## Удалить неотслеживаемые изменения
git clean
	-n	# проверить, что будет удаляться
	-f	# удалить

# Ветки
git branch	# посмотреть имеющиеся ветки
	<branch_name>		# создать ветку
	-d <branch_name>	# удалить ветку
	-D <branch_name>	# удалить ветку в локальном репозитории
	<branch_name> <SHA>	# создать ветку c версией указанного коммита (можно ссылаться и на коммиты удалённых веток)
	-a					# список всех веток
	-r					# список удалённых веток
	--merged			# показывает соединённые ветки
	-m <branch_name_old> <branch_name_new>	# переименовать ветку

## Перейти к определённой версии
git checkout
	<file || SHA || branch || tag>			# перейти к версию файла, коммита или ветки
	-- <file>										# перейти к последней версии файла, оставаясь на той же ветке
	<SHA || part_of_the_commit_id> -- <file>	# вернуться к определённой версии файла. после этого необходимо сделать следующее:
		git reset HEAD <file>
		git checkout -- <file>
	-b <branch_name>								# создать и перейти в ветку

# Слить текущую ветку с другой веткой
git merge
	<branch_name>
	--no-ff <branch_name>	# не fast-forward merge, а recursive merge (сохраняет все коммиты)
## Существует множество инструментов для слития веток
git mergetool
## Также для сокращения количества возможных конфликтов следует
### строчки кода писать короткими
### коммиты делать маленькими и сфокусированными
### избегать лишних пробелов, табов и окончания строк
### чаще мерджить
### периодически подхватывать изменения из мастера

## Вернуться к коммиту
git revert <SHA || part_of_the_commit_id>

## Запилить последнюю версию проекта на GitHub
git push
	<name> <branch>
	<name> <local_branch>:<remote_branch>
	-u origin master	# после этого можно просто git push
	origin :<branch>	# удалить ветку в удалённом репозитории
	--tags				# залить теги на сервер
### GitHub не заботится о контроле доступа к репозиторию.
### Есть альтернативные варианты репозиториев: BitBicket, Gitosis, Gitorious.
### В последних 2 реализован контроль доступа.

# Загрузить последние изменения с сервера, но не сливать с веткой
git fetch	# для всех веток
	<name> <branch>	# для ветки <branch>

# Загрузить последние изменения с сервера и слить с текущей веткой
git pull	# fetch + merge
	--rebase	# fetch + rebase
	<name> <branch>	# из ветки <branch>


# Добавить в текущую ветку изменения коммита (из другой ветки, разумеется)
git cherry-pick
	<SHA>
	--edit <SHA>				# изменить сообщение коммита
	--no-commit <SHA_1> <SHA_2>	# взять изменения обоих коммитов, но не коммитить
	-x <SHA>					# добавляет в сообщение (cherry-picked from commit ...)
	--signoff <SHA>				# автор этого черрипикинга

# Вставить изменения перед текущими изменениями
git rebase	# выполняется после git fetch
	<branch>	# из ветки <branch>
	--continue	# продолжить после разрешения конфликта
	-i HEAD~3	# интерактивный процесс при котором коммиты можно
		# Эти команды появляются в файле, который предлагается изменить
		pick		# менять местами (далее это слово можно заменять)
		reword		# переименовывать
		edit		# изменять (в том числе и делить на несколько коммитов)
		squash		# соединить с предыдущим


## Скрыть изменения с последнего коммита
git stash
	save	# сохранить изменённые файлы (можно не писать)
	save "Stash message."	# Описание изменений
	save --keep-index	# спрятать только незастейдженные изменения
	save --include-untracked	# спрятать в том числе и новые (неотслеживаемые) файлы
	list				# список (стэк) спрятанных состояний
		--stat	# со статистикой
	show stash@{2}		# показать указанный стэш; по умолчанию — 0 элемент
		--patch	# аналог diff
	apply				# вернуть изменения
	drop				# удалить спрятанные изменения
	clear				# очищает список с изменениями
	apply stash@{2}		# вернуть указанное изменение (из списка); по умолчанию — 0 элемент
	drop stash@{2}		# удалить спрятанные изменения (из списка); по умолчанию — 0 элемент
	pop					# вернуть изменения и удалить их из списка (apply && drop)
	branch <branch> stash@{0}	# поместить спрятанные изменения в новую ветку


# Редактирование истории
git filter-branch
	[f] --tree-filter "bash_command"
		"rm -f passwords.txt"	# удаление нежелательного файла
		"find . -name '*.mp4' -exec rm {} \;"	# удаление нежелательных файлов
	--tree-filter "bash_command" -- --all		# применение команды ко всем веткам и коммитам
	--tree-filter "bash_command" -- HEAD		# применение команды к текущей ветке
	[f] --index-filter "git rm --cached --ignore-unmatch passwords.txt"	# гораздо более быстрое выполнение команды для большого репозитория
	-f --prune-empty -- --all					# удалить все пустые коммиты


???????????????????

# Подмодули
git submodule
	add git@example.com:css.git
	init	#
	update	# чтобы скачать подмодуль из интернета

# Проверка, залиты ли прежде всего изменения модуля:
git push --recurse-submodules=check
# Заливаются все изменения с подмодулями так:
git push --recurse-submodules=on-demand

???????????????????



# Мои команды
## Быстрый доступ к состоянию реопзитория
git config --global alias.s "status -s"
## Отображение дерева коммитов в удобном виде
git config --global alias.lg "log --oneline --decorate --all --graph"
## Время создания коммита
git show -s --date=iso-strict-local --pretty=format:'%ad' <SHA>



# Игнорирование файлов
## Информация об игнорируемых файлах содержится в файле проекта .gitignore
## В нём перечисляются все файлы и папки
## Кроме того, можно задавать регулярные выражения с помощью символов
*, ?, [aeiou], [0-9]
## !этот_файл_не_игнорируется.html
## Строчные комментарии начинаются с символа #
## В проекте следует игнорировать
##   - скомпилированный код
##   - архивы
##   - логи и базы данных
##   - файлы, сгенерированные операционной системой
##   - файлы, загруженные пользователем
## Гобальное игнорирование:
git config --global core.excludesfile ~/.gitignore_global
### По умолчанию, Git игнорирует пустые папки (следит только за файлами). Если же нужно создать пустую папку, то в неё также нужно добавить файл .gitkeep
## Можно исключить файл также в файле ./.git/info/exclude
## Это исключение будет доступно только на одной машине, в отличие от информации в .gitignore


# Дополнительные фишки
## Настройка автозаполнения в Git
curl -OL http://github.com/git/git/raw/master/contrib/completion/git-completion.bash
mv ~/git-completion.bash ~/.git-completion.bash
### Прописать в .bash_profile
if [ -f ~/.git-completion.bash ]; then
	sourse ~/.git-completion.bash
fi

## Отображение ветки и рабочей папки в терминале (работает при наличии .git-completion)
export PS1='\W$(__git_ps1 "(%s)")> '

# С помощью GitHub API можно обращаться к возможностям сайта из терминала

# Клиенты git с графическим интерфейсом
# # Mac
# http://gitx.org
# http://mac.github.com
# http://sourcetreeapp.com
# http://git-tower.com
# http://gitboxapp.com
# # Windows
# http://code.google.com/p/tortoisegit
# http://code.google.com/p/gitextensions
# http://windows.github.com
# # Multiplatform
# syntevo.com/smartgit
# https://git.wiki.kernel.org/index.php/Gitweb


# Источники
# [V] https://try.github.io (введение в Git)
# [ ] https://www.codeschool.com/learn/git (практический курс)
# [ ] https://www.lynda.com/Git-tutorials/Git-Essential-Training/100222-2.html (теоретический курс)
# [ ] https://git-scm.com/book/en/v2 (лучшая книжка по Git)
# [ ] https://git-scm.com (графический интерфейс)
# [ ] https://desktop.github.com (полезное приложение)
# [ ] https://github.com/github/gitignore (про игнорирование файлов)
# [ ] https://help.github.com/articles/ignoring-files (про игнорирование файлов)
# [ ] https://help.github.com/articles/set-up-git (настроить Git так, чтобы не вводить пароль при обмене данными с сервером)
# [ ] http://gitimmersion.com
# [ ] http://gitready.com
# [ ] http://ndpsoftware.com/git-cheatsheet.html (шпаргалка)
# [ ] http://ftp.newartisans.com/pub/git.from.bottom.up.pdf
# [ ] https://github.com/pluralsight/git-internals-pdf
# Статьи
# [ ] http://nvie.com/posts/a-successful-git-branching-model/
# [ ] http://scottchacon.com/2011/08/31/github-flow.html
# [ ] http://semver.org (про версификацию)